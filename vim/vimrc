augroup VIMRC
	autocmd!
augroup END

" defaults.vim
set list listchars=tab:>-,extends:\\u00bb,precedes:\\u00ab,eol:\\u21b5,nbsp:~

augroup VIMRC
	autocmd BufEnter * execute 'setlocal listchars=tab:>-,extends:\\u00bb,precedes:\\u00ab,eol:\\u21b5,nbsp:~,multispace:┆' . repeat('\ ', &sw - 1)
augroup END
set backspace=indent,eol
set number relativenumber

set history=500
set ruler

set showcmd " show currently typed command (as in y)
set wildmenu

" timeout for mapping delay, ttimeout for key code delay
set timeout ttimeout timeoutlen=2000 ttimeoutlen=50

set display=lastline  " defaults.vim sets it to truncate but this seems to make more sense
set scrolloff=2

set hlsearch incsearch

set nrformats-=octal nrformats+=unsigned

set wildmode=longest:list,full

set ignorecase smartcase

set laststatus=2

set splitright splitbelow

nnoremap <silent> <Esc><Esc> :<C-u>nohlsearch<CR>
" often misfires
nnoremap <silent> <F1> <Nop>
" 'stronger' h and l.
nnoremap <C-h> ^
vnoremap <C-h> ^
nnoremap <C-l> $
vnoremap <C-l> $

if has('termguicolors')
	set termguicolors
endif

augroup VIMRC
	autocmd!
	autocmd ColorScheme * hi ExtraWhiteSpace ctermbg=darkgrey guibg=darkgrey
	autocmd ColorScheme * hi ZenkakuSpace ctermbg=white guibg=white
	autocmd BufEnter * call s:syntax_additional()
augroup END
function! s:syntax_additional()
	let l:matches = [
				\ matchadd("ZenkakuSpace", '　', 0),
				\ matchadd('ExtraWhiteSpace', '\s\+$',0),
				\ ]
	return l:matches
endfunction

augroup MiVLive
	autocmd!
	autocmd BufWritePost .vimrc.yaml call system('miv generate')
	autocmd BufWritePost vimrc.yaml call system('miv generate')
augroup END

" miv
filetype off
if has('vim_starting')
	set rtp^=~/.vim/miv/miv
endif
filetype plugin indent on
syntax enable

" vim: set noexpandtab ts=4 sw=4 sts=4 fdm=marker fmr=<<<,>>> :
