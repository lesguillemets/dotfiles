plugin:
  # Basal Editing <<<
  ## Asyncomplete
  prabirshrestha/asyncomplete.vim:
    after: |
      inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
      inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
      noremap <expr> <cr>    pumvisible() ? asyncomplete#close_popup() : "\<cr>"
      inoremap <expr> <cr>   pumvisible() ? asyncomplete#close_popup() . "\<cr>" : "\<cr>"
  prabirshrestha/asyncomplete-file.vim:
    dependon:
      - asyncomplete
    after: |
      au User asyncomplete_setup call asyncomplete#register_source(
        \ asyncomplete#sources#file#get_source_options({
        \ 'name': 'file',
        \ 'allowlist': ['*'],
        \ 'priority': 10,
        \ 'completor': function('asyncomplete#sources#file#completor')
        \ }))
  prabirshrestha/asyncomplete-buffer.vim:
    dependon:
      - asyncomplete
    after: |
      call asyncomplete#register_source(
          \ asyncomplete#sources#buffer#get_source_options({
          \ 'name': 'buffer',
          \ 'allowlist': ['*'],
          \ 'blocklist': [],
          \ 'completor': function('asyncomplete#sources#buffer#completor'),
          \ 'config': {
          \    'max_buffer_size': 5000000,
          \  },
          \ }))
  yami-beta/asyncomplete-omni.vim:
    dependon:
      - asyncomplete
    after: |
      autocmd User asyncomplete_setup call asyncomplete#register_source(
        \ asyncomplete#sources#omni#get_source_options({
        \ 'name': 'omni',
        \ 'allowlist': ['*'],
        \ 'blocklist': ['c', 'cpp', 'html'],
        \ 'completor': function('asyncomplete#sources#omni#completor'),
        \ 'config': {
        \   'show_source_kind': 1,
        \ },
        \ }))

  ## LSP
  prabirshrestha/vim-lsp:
    dependon:
      - asyncomplete
      - vim-lsp-ale
    after: |
      function! s:on_lsp_buffer_enabled() abort
          setlocal omnifunc=lsp#complete
          setlocal signcolumn=yes
          if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
          nmap <buffer> gd <plug>(lsp-definition)
          nmap <buffer> gs <plug>(lsp-document-symbol-search)
          nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
          nmap <buffer> gr <plug>(lsp-references)
          nmap <buffer> <leader>rn <plug>(lsp-rename)
          nmap <buffer> [g <plug>(lsp-previous-diagnostic)
          nmap <buffer> ]g <plug>(lsp-next-diagnostic)
          nmap <buffer> K <plug>(lsp-hover)
          let g:lsp_format_sync_timeout = 1000
          let g:lsp_diagnostics_float_cursor = 1
      endfunction
      augroup lsp_install
          autocmd!
          autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
      augroup END
  mattn/vim-lsp-settings:
    dependon:
      - lsp
  prabirshrestha/asyncomplete-lsp.vim:
    dependon:
      - asyncomplete
      - lsp


  ### ALE
  dense-analysis/ale:
    dependon:
      - vim-lsp-ale
    before: |
      let g:ale_cursor_detail = 1
      let g:ale_floating_preview = 0
      let g:ale_floating_window_border = ['│', '─', '╭', '╮', '╯', '╰', '│', '─']
      let g:ale_keep_list_window_open = 1
      let g:ale_open_list = 1
  rhysd/vim-lsp-ale:
    loadbefore:
      - ale
      - lsp
  # >>>

  # Editing <<<
  cohama/lexima.vim: {}

  ctrlpvim/ctrlp.vim:
    before: |
      let g:ctrlp_follow_symlinks = 1
      let g:ctrlp_custom_ignore = {}
      let g:ctrlp_custom_ignore.file = '\v\.(hi|o|out|jsmod|vo|v\.d|glob|pyc)$'
      let g:ctrlp_custom_ignore.dir = '\v[\/](\.stack-work|target|\.cabal-sandbox)$'
      let g:ctrlp_show_hidden = 1
  mattn/ctrlp-matchfuzzy:
    dependon:
      - ctrlp
    after: |
      let g:ctrlp_match_func = {'match': 'ctrlp_matchfuzzy#matcher'}
  # >>>

  # Filetypes <<<
  mattn/emmet-vim:
    filetype:
      - html
      - css
    before: |
      let g:user_emmet_install_global = 0
      augroup EMMET
      autocmd!
      autocmd FileType html,css EmmetInstall
      augroup END

  rust-lang/rust.vim:
    before: |
      let g:rustfmt_autosave = 1


  rhysd/committia.vim: {}

  # >>>

  # Appearance <<<
  itchyny/lightline.vim:
    before: |
      let g:lightline = {
        \ 'colorscheme': 'jellybeans',
        \ }

  ## Colourschemes
  nanotech/jellybeans.vim:
    after: |
      let g:jellybeans_use_term_italics = 1
      let g:jellybeans_overrides = {'background': { 'ctermbg': 'none', '256ctermbg': 'none' }}
      if has('termguicolors') && &termguicolors
          let g:jellybeans_overrides['background']['guibg'] = 'none'
      endif
      augroup JellyJelly
        autocmd!
        autocmd GUIEnter let g:jellybeans_overrides['background'] = {}
      augroup END
  sainnhe/everforest:
    after: |
      let g:everforest_transparent_background=1

  rhysd/vim-color-spring-night: {}
  preservim/vim-colors-pencil: {}
  # >>>

after: |
  colorscheme jellybeans

filetype:
  rust: |
    inoremap <C-l> <Space>->
  html: |
    setlocal noexpandtab
    setlocal ts=2 sts=2 sw=2
  css: |
    setlocal noexpandtab
    setlocal ts=2 sts=2 sw=2
  markdown: |
    let g:markdown_recommended_style=0
    setlocal noexpandtab
    setlocal ts=2 sts=2 sw=2

# vim: set expandtab ts=2 sw=2 sts=2 fdm=marker fmr=<<<,>>> :
